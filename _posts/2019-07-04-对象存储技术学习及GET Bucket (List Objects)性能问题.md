---
layout:     post
title:      "对象存储的优势及实习问题记录"
subtitle:   "我的定义：REST 式 URL 的文件存储（没有任何必要提及网络，URL本身就有这个意思）"
date:       2019-06-13 22:33:14
author:     "Ubik"
header-img: "img/post-bg-universe.jpg"
catalog: true
comments: true
tags:
    - 对象存储
    - 笔记
---

# 对象存储
“对象存储”来源于英文“Object Storage”或“Object-based Storage”

### 特性与目标
多租户
不假设数据特征，包括类型，大小等
存储空间可无限扩展，且性能该随容量水平扩展而线性提升，不然数据量越大，请求越多，性能却不提升，系统的存取性能只会越来越慢
数据安全
服务高可靠

### 索引设计
顶级命名空间service+bucket即可

### 元信息
属于哪个存储空间
类型
大小
校验值
最后修改时间

#### 特殊元信息
演唱者是谁
作词者是谁
作曲者是谁
属于哪张唱片
属于什么风格

# 对比
传统存储中，块存储暴露Block 文件系统或者网络文件系统如NFS暴露POSIX接口
## DAS  Direct-Attached Storage
直连式存储。直接连接到某台计算机且其他计算机无法获取，如PC的硬盘驱动器。因为服务器无需通过网络来读写数据，所以DAS能为终端用户提供比网络存储更高的性能。如微软公司推荐使用DAS安装Exchange。
缺点是依赖服务器主机操作系统进行数据的IO读写和存储维护管理，数据备份和恢复要求占用服务器主机资源（包括CPU、系统IO等）。直连式存储的数据量越大，备份和恢复的时间就越长，对服务器硬件的依赖性和影响就越大。 

## NAS  Network-Attached Storage
网络附属存储/网络接入存储
简单说就是连接在网络上，具备资料存储功能的装置，也因此称为网络存储器。将存储设备与服务器彻底分离，底层磁盘通过文件系统类型（分区，格式化后）通过网络的方式（发送ip包）共享给前端应用
##  SAN Storage Area Network
存储区域网络
 通过光纤设备将存储设别和服务器连接一起，数据和服务器分离，底层磁盘以块的模式共享给前端的应用服务器。
 SAN是一个采用网状通道（简称FC）技术，通过FC交换机连接存储阵列和服务器主机，建立专用于数据存储的区域网络。
 ![插图]({{site.baseurl}}/img/in-post/5E33AC1A918F56A6FFCF48F433A594BF.jpg)
 
 
# 优势
- 服务可用性更高
通过支持对象数据的高可靠性和业务节点的高可靠性网络、节点的多冗余设计，系统设计可用性达到99.99%。

- 数据可靠性更高
通过提供对象数据多份冗余和保证多份对象的数据一致性自动修复技术来提供对象数据的高可靠性。OBS系统设计的数据持久性高达99.999999999%（11个9），意为对象存储服务里1000亿个用户文件，每月最多只有1个文件发生数据丢失的可能性。

- 用户数据更安全
用户数据传输到OBS时支持SSL加密，同时，OBS通过AK/SK对访问用户的身份进行鉴权，且结合了ACL、桶策略等多种方式对桶和对象进行访问控制，确保数据传输与访问的安全。此外，用户所上传的对象数据在对象存储服务中分片随机存储在不同硬盘上，所以即便磁盘数据被盗走，也无法将其还原成对象数据。

- 容量无限扩展
OBS所有业务、存储节点采用分布式集群方式工作，各功能节点、集群都可以独立扩容，整个扩容过程对用户完全透明。用户只需尽情享用云存储带来的无限空间，不必预测未来的存储需求并可以按需要向上和向下扩展，从而大幅提高业务灵活性。

- 维护成本更低
由于数据存储在OBS中，企业无需招聘专门的存储设备维护人员，设备的维护交由OBS处理即可。

# 实习问题记录
## 为什么GET Bucket (List Objects)在Object多时会慢？
原问题“get bucket那个接口的实现比较麻烦，在object的量很大的情况下，这个接口的性能会很差。你可以想想这个问题”
根据API文档所说
1. 数据量大，多次循环调用该 API才可获得给定 Prefix 条件的所有对象列表。不像其他API只需要一次Http通信；网络通信次数多，
2. 需要模拟文件系统的目录结构，对delimiter划分的相同前缀的多个对象遍历和合并。底层实现需要较深的函数调用栈或者内存空间。
3. Object数量多时更改更频繁，缓存容易失效

不知道元信息的存储系统是否支持事务，如果不支持，并发情况下我觉得会加共享锁（读锁），锁竞争也会带来性能开销。可以用redis、zookeeper做分布式协调组件的情况下，可以多个请求竞争一个锁，只有一个请求到达并被处理，然后更新缓存供其他请求使用，从而提高吞吐量

就是关于 GET Bucket (List Objects)在Object多时性能很差的问题，有没有这几个原因
1. 网络IO次数多。根据文档所说，利用marker参数多次迭代调用该 API才可获得给定 Prefix 条件的所有对象列表。
2. 计算资源消耗大。文档说支持用delimiter模拟文件系统的目录结构，对delimiter划分的相同前缀的多个对象遍历和合并。这需要较深的函数调用栈或者内存空间以及计算量。
3. 保持实时性和一致性带来的开销。如文档所说，缓存容易失效，这会导致更多磁盘IO和数据处理。且读取过程中要加共享锁防止元数据被修改导致的一致性问题。

 
看文档我觉得服务器应该是一次完成所有数据的处理，但要分段返回是因为数据可能太大吗？

关于处理方法
文档说因为性能问题不要依赖这个接口的并发调用，而是用户自己缓存数据，这是不是说对数据的准确性要求不太高。那这样后端在并发情况下通过选举其中一个请求到达服务器，从mysql或别的拿到结果放入缓存，其他请求都走缓存，就可以一定程度解决吞吐量的问题。同样，通过elasticsearch或者其他放弃事务机制的搜索方式元数据提高响应速度

## Q：“假设现在数据量在单机承受能力之内，用mysql来存储元信息，怎么处理list请求”


比如按照Zone划分表，表中有所属bucket信息，类型，大小，校验值，最后修改时间，特殊元信息等字段，可以在编程语言层面记录已经处理过的bucket，实现下次根据marker参数继续处理。事务机制（隔离性）可以方便地保证一致性问题，同时可以对marker或其他字段走索引加快IO速度。
mysql8之后已不自带缓存，如文档所说如果要加缓存可以用redis。同时在编程语言层面利用元信息的最后修改时间字段实现缓存自动更新。

