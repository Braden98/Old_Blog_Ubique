---
layout:     post
title:      "幂等性解决方案初探"
subtitle:   "技术上避免抢月饼被开除问题"
date:       2019-03-13 12:13:14
author:     "Ubik"
header-img: "img/post-bg-rwd.jpg"
catalog: true
comments: true
tags:
    - 幂等性
    - 设计
    - 分布式
---


幂等性原是数学上的概念，表述如下

`f(f(x)) = f(x)`


对应到软件领域，即为多次调用同一接口，结果一致。这里的结果包括服务器数据、状态，不包括返回值（如第一次写入成功，后续应为抛出异常或空操作，删除同理）。简单理解就是**接口的可重复调用**。
注意，数学上和工业上的**幂等**差别非常大，以下考虑都基于工业上的幂等。

# 举例

1. 前端对同一表单数据的重复提交，后台应该只会产生一个结果

2. 发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱
3. 发送消息，也应该只发一次，同样的短信如果多次发给用户，用户会崩溃
4. 创建业务订单，一次业务请求只能创建一个，不能出现创建多个订单

# 解决方案
### 1. 全局ID
在执行操作前先根据这个全局唯一ID是否存在，来判断这个操作是否已经执行。如果不存在则把全局ID，存储到存储系统中，比如数据库、Redis等。如果存在则表示该方法已经执行。

### 2. 去重表

这种方法适用于在业务中有唯一标的插入场景中，比如在以上的支付场景中，如果一个订单只会支付一次，所以订单ID可以作为唯一标识。这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，在我们实现时，把创建支付单据和写入去去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。

这是利用数据库表单的特性来实现幂等。以订单请求支付场景为例：
将订单号orderId设为去重表的唯一索引，每次请求支付都根据订单号向去重表中插入一条数据，只有插入成功才继续执行支付操作，相当于在事务的开始阶段加锁。
考虑两种失败的情况：

Insert去重表失败，事务回滚，无任何影响；
Insert去重表成功，支付业务操作失败，事务回滚，删除之前插入去重表的记录，无任何影响；
以上两种失败的情况下，事务的幂等性是可以保持的，避免了单个订单同时多次进行支付的情况。
下图为该支付场景下的时序图：


![插图]({{site.baseurl}}/img/in-post/7B339387CF3E7D841EAE7E1CC3FCE9BB.jpg )

### 3. 插入或更新

这种方法插入并且有唯一索引的情况，比如我们要关联商品品类，其中商品的ID和品类的ID可以构成唯一索引，并且在数据表中也增加了唯一索引。这时就可以使用InsertOrUpdate操作

### 4. 分布式锁

在传统的基于数据库的架构中，对于数据的抢占问题往往是通过数据库事务（ACID）来保证的。在分布式环境中，出于对性能以及一致性敏感度的要求，使得分布式锁成为了一种比较常见而高效的解决方案。

> 基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。

与去重表思路相同，只是将对数据库的的访问转移到了对缓存（如redis）的访问，提高了效率。具体操作如下：
订单发起支付请求，支付系统会去redis缓存中查询是否存在该订单号orderId的key，如果不存在，则向redis增加key为订单号，然后开始实际支付操作；如果查询到存在该订单号的key，则不进行实际支付操作。无论支付操作成功或失败，在支付操作结果返回后，在缓存中删除该订单号key。

# 举例
## 如何防范表单 (POST) 重复提交？
HTTP POST 操作既不是安全的，也不是幂等的（至少在HTTP规范里没有保证）。当我们因为反复刷新浏览器导致多次提交表单，多次发出同样的POST请求，导致远端服务器重复创建出了资源。所以，对于电商应用来说，第一，对应的后端 WebService 一定要做到幂等性；第二，服务器端收到 POST 请求，在操作成功后必须302跳转到另外一个页面，这样即使用户刷新页面，也不会重复提交表单。
## 分布式下异步
分布式的很多业务考虑更多的是 BASE（即Basically Available、Soft state、和Eventually consistent），而不是 ACID（Atomicity、Consistency、Isolation和 Durability）。即为了满足高负载的用户访问，我们可以容忍短暂的数据不一致。那怎么做呢？

不做分布式事务，代价太大
不一定需要实时一致性，只需要保证最终的一致性即可
通过状态机和严格的有序操作，来最大限度地降低不一致性
最终一致性（Eventually Consistent）通过异步事件做到
如果消息具有操作幂等性，也就是一个消息被应用多次与应用一次产生的效果是一样的话，那么把不需要同步执行的事务交给异步消息推送和订阅者集群来处理即可。假如消息处理失败，那么就消息重播，由于幂等性，应用多次也能产生正确的结果。

实际情况下，消息很难具有幂等性，解决方法是使用另一个表记录已经被成功应用的消息，即消息队列和消息应用状态表一起来解决问题。
# 参考资料

1. [幂等的实现方案](https://segmentfault.com/a/1190000015884659)
2. [使用数据库唯一键实现事务幂等性](https://www.caosh.me/be-tech/idempotence-using-unique-key/)