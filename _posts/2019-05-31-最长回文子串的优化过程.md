---
layout:     post
title:      "最长回文子串的优化过程"
subtitle:   "从 O(n^3) 到 O(n)"
date:       2019-04-01 11:00:00
author:     "Ubik"
header-img: "img/post-bg-miui6.jpg"
catalog: true
comments: true
tags:
    - 算法
    - 优化
---

这里分享一道有趣的题目，笔者在 POJ 上使用多种不同的方法进行求解，这其中包括最基本的蛮力法、动态规划、分治算法+字符串哈希以及 Manacher 算法和后缀数组。
## 问题描述
>聪明的计算机科学的学生安迪正在参加一个算法课，教授问学生一个简单的问题：“你能提出一个有效的算法来找出字符串中最大回文长度吗？”
如果一个字符串向前和向后读相同，例如“madam”是回文，而“ACM”则不是回文，则称为回文。
学生们认识到这是一个经典的问题，但无法给出一个比遍历所有子串和检查它们是否是回文的方法更好的解答，过了一会儿安迪举起手说：“好吧，我有一个更好的。”在他开始解释他的想法之前，他停了一会儿，然后说：“嗯，我有一个更好的算法！”.
如果你认为你知道安迪的最终解决方案，那就证明它吧！给定一个最多1000000个字符的字符串，查找并打印字符串中最大回文长度。

## 暴力法
枚举字符串的每一个子串，判断其是否是回文串，如果是且比 `res.length()`，就更新 res 。枚举每个字串需要 O(n^2) 的时间复杂度，判断每一个子串是否为回文串需要 O(n) 的时间复杂度，因此，总的时间复杂度为 O(n^3). 思路非常简单，这里不再赘述,实现如下。
```Java
public String longestPalindrome(String s) {
        if(s.isEmpty()){
            return s;
        }
        String res=s.substring(0,1);
        for (int i = 0; i < s.length(); i++) {
            for (int j = i + 1; j <= s.length(); j++) {
                String k=s.substring(i,j);
                String rk=new StringBuffer(k).reverse().toString();
                if(k.equals(rk)&&k.length()>res.length()){
                    res=k;
                }
            }
        }
        return res;
    }
```

## 动态规划法
因为之前解决过最长公共子串 LCS 的问题，于是很自然地想到，将题目所给字符串倒置，利用回文串正序读和逆序读结果一样的特性，对其求 LCS ，res 就是本题的答案。
但在制作 case 的时候，笔者发现这是错误的解法，因为一旦原来的字符串中已经同时存在某个字串及其逆序，这个算法就无法找到最长的那一个。
所以应该换如下思路：令 `dp[i][j]` 表示 `S[i]~S[j]` 所表示的子串是否是回文子串，是则为1，不是则为0，这样根据 `S[i]是否=S[j]` ，可以把转移情况分成两类

1.  `S[i]==S[j]` ,那么只要 `S[i+1]～S[j-1]` 是回文子串，那么 `S[i]~S[j]` 就是回文子串，如果 `S[i+1]～S[j-1]` 不是回文子串，那么 `S[i]~S[j]` 就不是回文子串。
2.  `S[i]!=S[j]` ，那么 `S[i]~S[j]` 就不是回文子串。

由此可得状态转移方程 
```Java
dp[i][j]=S[i]==S[j]? dp[i+1][j-1]:0;
```
但还有一个问题，对于该状态转移方程，如果按照 i 和 j 从小到大的顺序来枚举子串的两个端点，然后更新 `dp[i][j]` ，会无法保证 `dp[i+1][j-1]` 已经被计算过，出现空指针异常。注意到回文子串的对称性，通过手动计算 dp 二维数组，发现可通过枚举子串长度的方式进行第一轮遍历，第二遍按照子串的初始位置进行遍历，如此，即可获得正确的dp数组。
时间复杂度方面，先枚举子串的长度再枚举作第一轮循环，再枚举子串的起始端点作为第二轮循环，因此时间复杂度为 O(n^2),比最基本的蛮力法要好多了。关键代码如下所示（笔者大二上提交 OJ 的 C++ 代码）
``` C++
for (int L = 3; L <= len; L++)//枚举子串的长度作为一轮遍历的方法
{
    for (int i = 0; i + L - 1 < len; i++)//枚举子串的起始端点作为第二轮循环
    {
        int j = i + L - 1;//子串的右端点
        if (S[i] == S[j] && dp[i + 1][j - 1] == 1) {
            dp[i][j] = 1;
            ans = L;//更新最长回文子串长度
        }
    }
```
对于该二重循环，显然其时间复杂度为 O(n^2)。
## 字符串 Hash & 二分

## Manacher 算法

##